# NPHY_nr-ue
## vThread_L1 Protocol 설명
### ***Symbol or Bit Data Send Method***

### **SER or BER Performance calculation**

**: Symbol or Bit Data를 보내기 위해 필요한 함수 및 변수 설명**

**: NPHY_thread_L1에서 Bit Data를 처리하는 과정 및 코드 설명**


## 코드 구현 ( C )

**1. Symbol or Bit Data를 보내기 위해 필요한 함수 및 변수 설명**

**1-1) 변수 설명**
``` 
#define bitsend
#define symbolsend
#define DBGBER
``` 
→  Bit Data를 보내고 싶은 경우, bitsend 변수 켜주기

→ Symbol Data를 보내고 싶은 경우, symbolsend 변수 켜주기

→ BER를 디버깅하고 싶은 경우, DBGBER 변수 켜주기

(BER은 STLC에서만 확인해 봄. SISO, STBC의 경우에 이상하면 변수켜서 확인하기)
``` 
//symbol data buffer
short txdatabuf[100]={23169, -23169, 23169, 23169, -23169, -23169, -23169, 23169, 23169, 23169,,,,}										
int dataLength = 10;

//bit data buffer
short txbitbuf[NPHY_FFTSIZE][NPHY_BITDATASize] ={0,};		
short txbitbuf10[NPHY_BITDATASize]={0,};					
```
→ txdatabuf는 Symbol Data, txbitbuf는 Bit Data 정보를 저장하고 있는 Buffer

→ txdatabuf는 data를 채워둔 후, dataLength라는 변수를 이용하여 길이를 조절할 수 있음

→ NPHY_FFTSIZE = 1024으로 data의 총 개수인 2의 10승, 즉 1024가지의 데이터를 담을 수 있게 설정해 둠

→ NPHY_BITDATASize = 10으로 data 1개를 나타내는 bit가 10bit임을 나타내 줌



**1-2) void gen_bitdata()**

→ Data를 10 bit로 0 ~ 1023을 표현하여 txbitbuf에 넣어줌

→ ex) 1023 = 1 1 1 1 1 1 1 1 1 1 로 표현가능

→ p0~p9는 slotCnt를 2진수로 나타냈을 때, 각 자리당 해당하는 숫자를 의미함

(이때, 0부터 차례대로 9번까지 해당하는 숫자를 쓰면 원하는 이진수를 표현하도록 설정해 둠)
```
void gen_bitdata(void){
	
	int slotCnt = 0;
	int p0 = 0;
	int p1 = 0;
	int p2 = 0;
	int p3 = 0;
	int p4 = 0;
	int p5 = 0;
	int p6 = 0;
	int p7 = 0;
	int p8 = 0;
	int p9 = 0;

	for(int i=0; i<NPHY_FFTSIZE; i++)
	{

		p0 = slotCnt/512 ;
		p1 = (slotCnt %512)/256;
		p2 = ((slotCnt %512)%256)/128;
		p3 = (((slotCnt %512)%256)%128)/64;
		p4 = ((((slotCnt %512)%256)%128)%64)/32;
		p5 = (((((slotCnt %512)%256)%128)%64)%32)/16;
		p6 = ((((((slotCnt %512)%256)%128)%64)%32)%16)/8;
		p7 = (((((((slotCnt %512)%256)%128)%64)%32)%16)%8)/4;
		p8 = ((((((((slotCnt %512)%256)%128)%64)%32)%16)%8)%4)/2;
		p9 = ((((((((slotCnt %512)%256)%128)%64)%32)%16)%8)%4)%2;
			
		txbitbuf[i][0] = p0;
		txbitbuf[i][1] = p1;
		txbitbuf[i][2] = p2;
		txbitbuf[i][3] = p3;
		txbitbuf[i][4] = p4;
		txbitbuf[i][5] = p5;
		txbitbuf[i][6] = p6;
		txbitbuf[i][7] = p7;
		txbitbuf[i][8] = p8;
		txbitbuf[i][9] = p9;

		slotCnt = slotCnt +1;

		}
}
```


**1-3) uint8_t NPHY_decideNbAnt()**

→  STLC의 경우, 1X2 STLC를 현재 실험하고 있음

 → 1X2 STLC는 TX ANT: 1, RX ANT:2 임을 아래 코드에서 확인 할 수 있음
 
```
uint8_t NPHY_decideNbAnt(void)
{
	uint8_t output = 1;

#if (defined MOD_STBC || defined MOD_STLC)
	if (ndType == 0) //RX
	{
		switch(txMode)
		{
			case 2: //STLC RX
				output = 2;
				break;
			case 1: //STBC RX
			case 0: //single
			default : 
				output=1;
		}
	}
	else
	{
		switch(txMode)
		{
			case 1: //STBC TX
				output = 2;
				break;	
			case 2: //STLC TX
			case 0: //single
			default : 
				output=1;
		}
	}
#endif

	return output;
}
```


**2. NPHY_thread_L1에서 Bit Data를 처리하는 과정 및 코드 설명**

**2-1) 변수 설명**
``` 
int DataNum = 0;					// 0 ~ 1023
int detectNum = 0;					// finding dataNum
```
**2-2) static void NPHY_thread_L1 과정**
![]()
**2-3) static void NPHY_thread_L1 코드설명**
```
```


![]()


> Written with [StackEdit](https://stackedit.io/).

