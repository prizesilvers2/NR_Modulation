# vTX
## vThreadtx 설명
### **Preamble Detection Method & Estimation Frequency Offset**

### ***How to get preamble dump file in sending bit data***

**: TX에서의 Preamble detection 방법과 Frequency offset추정 함수 및 코드 설명**

**: Bit Data를 전송시, RX에서 보내는 Preamble Dump file 받는 방법 및 코드 설명**


## 코드 구현 ( C )

***1. TX에서의 Preamble detection 방식과 Frequency offset추정  함수 및 코드 설명***

**1-1) 변수 설명**
``` 
#define VTX_DBGPROC

#ifdef	MOD_STLC
#define VTX_SYNC_WINDOW_SIZE					300
#define VTX_ONLINE_THRES_PREAMBLEDETECTION		2
#define VTX_DEFAULT_THRES_PREAMBLEDETECTION		20
#endif
``` 
→  

→ 

→ 

``` 
				
```
→ 

→ 

→ 

→ 



**1-2) int8_t vtx_configInit()**

> 
>
>
>
> 
> 
> 
```
#if (defined MOD_STBC || defined MOD_STLC)
	//Antenna definition 
	if (cfgInfo->mode == hw_trxMode_siso || cfgInfo->mode == hw_trxMode_1x2STLC)
		cfgInfo->TXAnt_nb = 1;
	else if (cfgInfo->mode == hw_trxMode_2x1STBC)
		cfgInfo->TXAnt_nb = 2;
#endif
```


**1-3) double vtx_estFreqOffsetFromPss()**

> 
>
> 
 
```
	result1  = dot_product64(preamble, 
				  rxdata, 
				  (seq_length>>1), 
				  shift);
	result2  = dot_product64(preamble+seq_length, 
				  rxdata+seq_length, 
				  (seq_length>>1), 
				  shift);

	int64_t re1,re2,im1,im2;
	re1=((int*) &result1)[0];
	re2=((int*) &result2)[0];
	im1=((int*) &result1)[1];
	im2=((int*) &result2)[1];

	return (atan2(re1*im2-re2*im1,re1*re2+im1*im2)/VHW_PI);
```

**1-4) static void vtx_commandFreqDrift()**

> 
>
> 
 
```
	AssertFatal ( 0== pthread_mutex_lock(&(vtx_rfRegPtr->sharedReg.sharedMutex)), "");
	vtx_rfRegPtr->sharedReg.freqDrift = freqDrift;
	AssertFatal ( 0== pthread_mutex_unlock(&(vtx_rfRegPtr->sharedReg.sharedMutex)), "");
```

**1-5) static int vtx_detectPreamble()**

> 
>
> 
 
```
	AssertFatal ( 0== pthread_mutex_lock(&(vtx_rfRegPtr->roReg.regMutex)), "");
	int slotSize = vtx_rfRegPtr->roReg.slotSize;
	AssertFatal ( 0== pthread_mutex_unlock(&(vtx_rfRegPtr->roReg.regMutex)), "");
	
	//modify window Size
	int start = 6800;		//6400
	int end = 7248;			//7000
	
	int64_t result = 0, max_result = 0;
	int64_t av_result = 0;
	int max_offset = 0; 
	int cnt = 0;
	int16_t maxval = 0;
	int shift;
	int16_t *ptr16;
	double f_off;
#ifdef VRX_CORHISTDUMP
	int64_t corr_hist[10000];
#endif

	LOG_D(PHY, "preamble detection trial in state %i and slot %i\n", state_sync, proc_nr);

	short vrx_preambleSeqBuf[2048];
	int vrx_preambleLen = 1024;

	memcpy(vrx_preambleSeqBuf,(short *)(&vtx_buffer[0][2][cfgInfo->tOffset_preamble]), cfgInfo->fftSize*sizeof(short)*2);
	
	//amplitude estimation -------------------------------------------------	
	ptr16 = &(vrx_preambleSeqBuf[0]);
	for (int i=0; i<2*vrx_preambleLen; i++)
	{
		maxval = max(maxval,ptr16[i]);
		maxval = max(maxval,-ptr16[i]);
	}
	shift = vhw_log2Approx(maxval);

	//window search command
	if (detect_offset > 0)
	{
		start = detect_offset - VTX_SYNC_WINDOW_SIZE;
		end = detect_offset + VTX_SYNC_WINDOW_SIZE;
	}
	
	#ifdef VTX_DBGPROC	
	LOG_I(PHY, "preamble detection start :::::: start : %i, end : %i\n", start, end);
	#endif
	for (int n=start; n < end; n+=4) // n= 0 ~ end-4 (slotSize)
	{ 
		if ( n < (slotSize - vrx_preambleLen) )
		{
			int64_t dotResult	= dot_product64(&(vrx_preambleSeqBuf[0]),
								(short*) &(vtx_rfRegPtr->roReg.rxData[proc_nr][0][n]), 
								  vrx_preambleLen, 
								  shift);

			result = vhw_abs64(dotResult);
			av_result += result;
		
			/* calculate the absolute value of sync_corr[n] */
			if (result > max_result)
			{
				max_result = result;
				max_offset = n;
			}
			cnt++;
		 }
	}

	av_result /= cnt;

	LOG_D(VTX, "[detection result] max_offset : %i \n" , max_offset);		
	

	if ((detect_offset == 0 && max_result < VTX_DEFAULT_THRES_PREAMBLEDETECTION*av_result) ||
		(detect_offset > 0 && max_result < VTX_ONLINE_THRES_PREAMBLEDETECTION*av_result))
	{
		LOG_D(VRX, "peak-to-average is below threshold! (max:%li av:%li) (start:%i, end:%i) end with assertion!\n", max_result, av_result, start, end);
		return(-1);
	}

	//f_off estmation :: angle, digital freq -----------------------------------
	f_off = vtx_estFreqOffsetFromPss(&(vrx_preambleSeqBuf[0]), (short*) &(vtx_rfRegPtr->roReg.rxData[proc_nr][0][max_offset]), vrx_preambleLen, shift);	
	
	//freqOffset = analog freq
	*freqOffset = (int)(f_off*(15360000.0/vrx_preambleLen));

	if (start == 0) // if it is full search
		LOG_I(PHY, "[VRX] Found preamble - offset : %i, max result : %li, av_result : %li, frequency offset : %lf (%lf)\n", 
								max_offset, max_result, av_result, f_off, f_off*(15360000.0/vrx_preambleLen));

	if (*freqOffset > 300 || *freqOffset < -300)
		LOG_E(PHY, "[VRX] WARNING ::: too large frequency offset : %i, needs to be compensated immediately\n", *freqOffset);

	
	return(max_offset);	
```
**1-6) TX에서 Preamble detection의 결과 및 디버깅문구 확인**
- TX에서 Preamble detection의 결과
>
>
![](https://github.com/prizesilvers2/NR_Modulation/blob/main/Figs/UL_preambledetection.png?raw=true)

- 디버깅문구 확인(Preamble detection 및 slot 계산처리에 걸리는 시간 확인)
>
>
![]()

***2. Bit Data를 전송시, RX에서 보내는 Preamble Dump file 받는 방법 및 코드 설명***

**2-1) 변수 설명**
``` 
#define bitsend 
#define dumpSize				100
#define VTX_DUMPFORCSI

// vTX_mainThread내에서 사용되는 변수
int time_offset=0;
int freqOffset;
int detect_offset=0;
int Datanum = 0;
int syncStatus=0;
int slot_nr=0;
int dumpCnt=0;
```
→ 

→ 

**2-2) void vTX_mainThread 과정**
![]()


**2-3) void vTX_mainThread 코드설명**

- 
> 
> 
> 
```
	
```
- 

>  
>  
>  
>  
>  
```

```

**2-4) RX에서 보내는 Preamble Dump file 받는 방법 및 코드 설명**

> Written with [StackEdit](https://stackedit.io/).

